# Docker Builder Service

Небольшое приложение на FastAPI для клонирования репозитория, сборки Docker-образа и опциональной отправки в реестр.

Цель этого репозитория — предоставить HTTP API для автоматической сборки образов. Этот README объясняет, как контейнеризовать и запускать сервис, а также какие нюансы учитывать при том, что само приложение вызывает Docker (git, docker, gcloud и т.п.).

Коротко о содержимом

- `app/` — исходники приложения (FastAPI)
- `tests/` — базовые тесты (используют dry_run)
- `requirements.txt` — зависимости Python

Можно ли запускать приложение в Docker?

Да. Приложение можно упаковать в Docker-образ и запускать в контейнере. Однако приложение само запускает системные команды (`git`, `docker`, опционально `gcloud`), поэтому чтобы оно могло управлять сборкой/пушем образов, нужно предоставить доступ к Docker-демону (или установить и запустить Docker внутри контейнера — Docker-in-Docker).

Два рекомендуемых варианта:

1) Подключение к Docker-демону хоста (рекомендуемое для удобства):
   - Примонтировать Unix-сокет `/var/run/docker.sock` в контейнер: контейнер использует docker CLI (клиент) и посылает команды демону хоста.
   - Плюсы: просто, быстро, не требует запуска dind.
   - Минусы: контейнер получает полномочия демона Docker хоста (высокий уровень доступа).

2) Docker-in-Docker (dind) через docker-compose (sidecar):
   - Запустить официальный `docker:dind` сервис и соединить приложение с ним (или использовать его как отдельный демон).
   - Плюсы: изоляция от демона хоста.
   - Минусы: нужно запускать `privileged` сервис, добавляется сложность и потенциальная накладная на производительность.

Учтите также:
- `gcloud` (Google Cloud SDK) не установлен в образ по-умолчанию. Если вы хотите использовать `gcloud auth print-access-token` для логина в GCR/Artifact Registry, установите SDK в образ или пробросьте соответствующие учётные данные/токены через секреты/переменные окружения.
- Для доступа к приватным реестрам рекомендуется использовать безопасную передачу учётных данных (через переменные окружения, Docker secrets, GCP Secret Manager). Не храните пароли в репозитории.

Что я добавил

- `Dockerfile` — образ на базе `python:3.11-slim`, с установкой `git` и `docker` CLI и установкой Python-зависимостей из `requirements.txt`.
- `docker-compose.yml` — демонстрационный файл с двумя опциями: с примонтированным Docker-сокетом хоста и с сервисом dind (можно использовать по необходимости).
- `.dockerignore` — чтобы не копировать лишние файлы в образ.
- `README.md` — этот файл.

Как собрать и запустить (локально)

1) Собрать образ локально и запустить с примонтированным Docker-сокетом:

```bash
# собрать образ
docker build -t docker-builder-service .

# запустить контейнер (примеры)
# Вариант A: использовать Docker хоста (простой)
docker run --rm -p 8000:8000 -v /var/run/docker.sock:/var/run/docker.sock -v "$PWD":/app docker-builder-service

# Вариант B: использовать docker-compose (включён сервис dind)
docker-compose up --build
```

2) В контейнере сервис доступен на http://localhost:8000

API

- POST /api/build — создать задачу сборки. Формат payload совпадает с Pydantic-моделью `CreateBuildPayload` в `app/main.py`.
- GET /api/build/{job_id} — получить статус и логи
- GET /api/builds — список задач

Пример payload (JSON):

```json
{
  "repo_url": "https://github.com/example/repo.git",
  "branch": "main",
  "tag": "v1.0.0",
  "registry": "example.registry/repo/image",
  "dockerfile_path": "Dockerfile",
  "push": true,
  "dry_run": true
}
```

Запуск тестов (локально, в venv)

```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
pytest -q
```

Безопасность и рекомендации

- Примонтированный `/var/run/docker.sock` даёт контейнеру высокий уровень контроля над Docker-демоном хоста — для production-окружений стоит рассмотреть изоляцию, RBAC, или отдельные билд-агенты.
- Для приватных реестров используйте менеджер секретов (например, GCP Secret Manager, HashiCorp Vault) или системные переменные окружения, а не храните пароли прямо в запросах.
- Рассмотрите запуск билд-работ в отдельном изолированном билдере (CI/CD), а не прямо в сервисе, если вам важна безопасность.

Дальше (опционально)

- Добавить health endpoint.
- Настроить логирование в файл/JSON и ротацию.
- Добавить инструкцию по деплою в Kubernetes (с описанием способа доступа к Docker или использованию Kaniko/BuildKit для сборок внутри кластера).

---
Автор: добавлен автоматически по запросу.

